Index: ChangeLog
===================================================================
--- ChangeLog	(.../v1_8_6_111)	(revision 14522)
+++ ChangeLog	(.../v1_8_6_113)	(revision 14522)
@@ -1,3 +1,9 @@
+Mon Dec  3 08:13:52 2007  Kouhei Sutou  <kou@cozmixng.org>
+
+	* test/rss/test_taxonomy.rb, test/rss/test_parser_1.0.rb,
+	  test/rss/test_image.rb, test/rss/rss-testcase.rb: ensured
+	  declaring XML namespaces.
+
 Sun Sep 23 21:57:25 2007  GOTOU Yuuzou  <gotoyuzo@notwork.org>  
 
 	* lib/net/http.rb: an SSL verification (the server hostname should
Index: version.h
===================================================================
--- version.h	(.../v1_8_6_111)	(revision 14522)
+++ version.h	(.../v1_8_6_113)	(revision 14522)
@@ -1,15 +1,15 @@
 #define RUBY_VERSION "1.8.6"
-#define RUBY_RELEASE_DATE "2007-09-24"
+#define RUBY_RELEASE_DATE "2007-12-03"
 #define RUBY_VERSION_CODE 186
-#define RUBY_RELEASE_CODE 20070924
-#define RUBY_PATCHLEVEL 111
+#define RUBY_RELEASE_CODE 20071203
+#define RUBY_PATCHLEVEL 113
 
 #define RUBY_VERSION_MAJOR 1
 #define RUBY_VERSION_MINOR 8
 #define RUBY_VERSION_TEENY 6
 #define RUBY_RELEASE_YEAR 2007
-#define RUBY_RELEASE_MONTH 9
-#define RUBY_RELEASE_DAY 24
+#define RUBY_RELEASE_MONTH 12
+#define RUBY_RELEASE_DAY 3
 
 #ifdef RUBY_EXTERN
 RUBY_EXTERN const char ruby_version[];
Index: lib/rexml/parsers/baseparser.rb
===================================================================
--- lib/rexml/parsers/baseparser.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/parsers/baseparser.rb	(.../v1_8_6_113)	(revision 14522)
@@ -1,5 +1,7 @@
 require 'rexml/parseexception'
+require 'rexml/undefinednamespaceexception'
 require 'rexml/source'
+require 'set'
 
 module REXML
   module Parsers
@@ -24,7 +26,8 @@
     # Nat Price gave me some good ideas for the API.
     class BaseParser
       NCNAME_STR= '[\w:][\-\w\d.]*'
-      NAME_STR= "(?:#{NCNAME_STR}:)?#{NCNAME_STR}"
+      NAME_STR= "(?:(#{NCNAME_STR}):)?(#{NCNAME_STR})"
+      UNAME_STR= "(?:#{NCNAME_STR}:)?#{NCNAME_STR}"
 
       NAMECHAR = '[\-\w\d\.:]'
       NAME = "([\\w:]#{NAMECHAR}*)"
@@ -35,7 +38,7 @@
 
       DOCTYPE_START = /\A\s*<!DOCTYPE\s/um
       DOCTYPE_PATTERN = /\s*<!DOCTYPE\s+(.*?)(\[|>)/um
-      ATTRIBUTE_PATTERN = /\s*(#{NAME_STR})\s*=\s*(["'])(.*?)\2/um
+      ATTRIBUTE_PATTERN = /\s*(#{NAME_STR})\s*=\s*(["'])(.*?)\4/um
       COMMENT_START = /\A<!--/u
       COMMENT_PATTERN = /<!--(.*?)-->/um
       CDATA_START = /\A<!\[CDATA\[/u
@@ -45,7 +48,7 @@
       XMLDECL_PATTERN = /<\?xml\s+(.*?)\?>/um
       INSTRUCTION_START = /\A<\?/u
       INSTRUCTION_PATTERN = /<\?(.*?)(\s+.*?)?\?>/um
-      TAG_MATCH = /^<((?>#{NAME_STR}))\s*((?>\s+#{NAME_STR}\s*=\s*(["']).*?\3)*)\s*(\/)?>/um
+      TAG_MATCH = /^<((?>#{NAME_STR}))\s*((?>\s+#{UNAME_STR}\s*=\s*(["']).*?\5)*)\s*(\/)?>/um
       CLOSE_MATCH = /^\s*<\/(#{NAME_STR})\s*>/um
 
       VERSION = /\bversion\s*=\s*["'](.*?)['"]/um
@@ -133,6 +136,7 @@
         @tags = []
         @stack = []
         @entities = []
+        @nsstack = []
       end
 
       def position
@@ -188,6 +192,7 @@
         end
         return [ :end_document ] if empty?
         return @stack.shift if @stack.size > 0
+        #STDERR.puts @source.encoding
         @source.read if @source.buffer.size<2
         #STDERR.puts "BUFFER = #{@source.buffer.inspect}"
         if @document_status == nil
@@ -213,6 +218,7 @@
             return [ :processing_instruction, *@source.match(INSTRUCTION_PATTERN, true)[1,2] ]
           when DOCTYPE_START
             md = @source.match( DOCTYPE_PATTERN, true )
+            @nsstack.unshift(curr_ns=Set.new)
             identity = md[1]
             close = md[2]
             identity =~ IDENTITY
@@ -288,6 +294,9 @@
                 val = attdef[3]
                 val = attdef[4] if val == "#FIXED "
                 pairs[attdef[0]] = val
+                if attdef[0] =~ /^xmlns:(.*)/
+                  @nsstack[0] << $1
+                end
               end
             end
             return [ :attlistdecl, element, pairs, contents ]
@@ -312,6 +321,7 @@
         begin
           if @source.buffer[0] == ?<
             if @source.buffer[1] == ?/
+              @nsstack.shift
               last_tag = @tags.pop
               #md = @source.match_to_consume( '>', CLOSE_MATCH)
               md = @source.match( CLOSE_MATCH, true )
@@ -345,19 +355,47 @@
                 raise REXML::ParseException.new("missing attribute quote", @source) if @source.match(MISSING_ATTRIBUTE_QUOTES )
                 raise REXML::ParseException.new("malformed XML: missing tag start", @source) 
               end
-              attrs = []
-              if md[2].size > 0
-                attrs = md[2].scan( ATTRIBUTE_PATTERN )
+              attributes = {}
+              prefixes = Set.new
+              prefixes << md[2] if md[2]
+              @nsstack.unshift(curr_ns=Set.new)
+              if md[4].size > 0
+                attrs = md[4].scan( ATTRIBUTE_PATTERN )
                 raise REXML::ParseException.new( "error parsing attributes: [#{attrs.join ', '}], excess = \"#$'\"", @source) if $' and $'.strip.size > 0
+                attrs.each { |a,b,c,d,e| 
+                  if b == "xmlns"
+                    if c == "xml"
+                      if d != "http://www.w3.org/XML/1998/namespace"
+                        msg = "The 'xml' prefix must not be bound to any other namespace "+
+                        "(http://www.w3.org/TR/REC-xml-names/#ns-decl)"
+                        raise REXML::ParseException.new( msg, @source, self )
+                      end
+                    elsif c == "xmlns"
+                      msg = "The 'xmlns' prefix must not be declared "+
+                      "(http://www.w3.org/TR/REC-xml-names/#ns-decl)"
+                      raise REXML::ParseException.new( msg, @source, self)
+                    end
+                    curr_ns << c
+                  elsif b
+                    prefixes << b unless b == "xml"
+                  end
+                  attributes[a] = e 
+                }
               end
         
-              if md[4]
+              # Verify that all of the prefixes have been defined
+              for prefix in prefixes
+                unless @nsstack.find{|k| k.member?(prefix)}
+                  raise UndefinedNamespaceException.new(prefix,@source,self)
+                end
+              end
+
+              if md[6]
                 @closed = md[1]
+                @nsstack.shift
               else
                 @tags.push( md[1] )
               end
-              attributes = {}
-              attrs.each { |a,b,c| attributes[a] = c }
               return [ :start_element, md[1], attributes ]
             end
           else
@@ -371,6 +409,8 @@
             # return PullEvent.new( :text, md[1], unnormalized )
             return [ :text, md[1] ]
           end
+        rescue REXML::UndefinedNamespaceException
+          raise
         rescue REXML::ParseException
           raise
         rescue Exception, NameError => error
Index: lib/rexml/parsers/treeparser.rb
===================================================================
--- lib/rexml/parsers/treeparser.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/parsers/treeparser.rb	(.../v1_8_6_113)	(revision 14522)
@@ -1,4 +1,5 @@
 require 'rexml/validation/validationexception'
+require 'rexml/undefinednamespaceexception'
 
 module REXML
   module Parsers
@@ -29,8 +30,7 @@
               return
             when :start_element
               tag_stack.push(event[1])
-              # find the observers for namespaces
-              @build_context = @build_context.add_element( event[1], event[2] )
+              el = @build_context = @build_context.add_element( event[1], event[2] )
             when :end_element
               tag_stack.pop
               @build_context = @build_context.parent
@@ -86,6 +86,8 @@
           end
         rescue REXML::Validation::ValidationException
           raise
+        rescue REXML::UndefinedNamespaceException
+          raise
         rescue
           raise ParseException.new( $!.message, @parser.source, @parser, $! )
         end
Index: lib/rexml/document.rb
===================================================================
--- lib/rexml/document.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/document.rb	(.../v1_8_6_113)	(revision 14522)
@@ -66,6 +66,7 @@
 		def add( child )
 			if child.kind_of? XMLDecl
 				@children.unshift child
+        child.parent = self
 			elsif child.kind_of? DocType
         # Find first Element or DocType node and insert the decl right 
         # before it.  If there is no such node, just insert the child at the
@@ -183,7 +184,7 @@
         output = Output.new( output, xml_decl.encoding )
       end
       formatter = if indent > -1
-          if transitive
+          if trans
             REXML::Formatters::Transitive.new( indent, ie_hack )
           else
             REXML::Formatters::Pretty.new( indent, ie_hack )
Index: lib/rexml/element.rb
===================================================================
--- lib/rexml/element.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/element.rb	(.../v1_8_6_113)	(revision 14522)
@@ -553,6 +553,7 @@
     def attribute( name, namespace=nil )
       prefix = nil
       prefix = namespaces.index(namespace) if namespace
+      prefix = nil if prefix == 'xmlns'
       attributes.get_attribute( "#{prefix ? prefix + ':' : ''}#{name}" )
     end
 
@@ -854,15 +855,15 @@
     #   Source (see Element.initialize).  If not supplied or nil, a
     #   new, default Element will be constructed
     # Returns:: the added Element
-    #  a = Element.new 'a'
-    #  a.elements.add Element.new 'b'  #-> <a><b/></a>
-    #  a.elements.add 'c'              #-> <a><b/><c/></a>
+    #  a = Element.new('a')
+    #  a.elements.add(Element.new('b'))  #-> <a><b/></a>
+    #  a.elements.add('c')               #-> <a><b/><c/></a>
     def add element=nil
       rv = nil
       if element.nil?
-        Element.new "", self, @element.context
+        Element.new("", self, @element.context)
       elsif not element.kind_of?(Element)
-        Element.new element, self, @element.context
+        Element.new(element, self, @element.context)
       else
         @element << element
         element.context = @element.context
Index: lib/rexml/undefinednamespaceexception.rb
===================================================================
--- lib/rexml/undefinednamespaceexception.rb	(.../v1_8_6_111)	(revision 0)
+++ lib/rexml/undefinednamespaceexception.rb	(.../v1_8_6_113)	(revision 14522)
@@ -0,0 +1,8 @@
+require 'rexml/parseexception'
+module REXML
+  class UndefinedNamespaceException < ParseException
+    def initialize( prefix, source, parser )
+      super( "Undefined prefix #{prefix} found" )
+    end
+  end
+end
Index: lib/rexml/source.rb
===================================================================
--- lib/rexml/source.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/source.rb	(.../v1_8_6_113)	(revision 14522)
@@ -17,8 +17,8 @@
       elsif arg.kind_of? Source
         arg
       else
-        raise "#{source.class} is not a valid input stream.  It must walk \n"+
-        "like either a String, IO, or Source."
+        raise "#{arg.class} is not a valid input stream.  It must walk \n"+
+          "like either a String, an IO, or a Source."
       end
     end
   end
@@ -134,6 +134,7 @@
     def initialize(arg, block_size=500, encoding=nil)
       @er_source = @source = arg
       @to_utf = false
+
       # Determining the encoding is a deceptively difficult issue to resolve.
       # First, we check the first two bytes for UTF-16.  Then we
       # assume that the encoding is at least ASCII enough for the '>', and
@@ -145,13 +146,16 @@
       str = @source.read( 2 )
       if encoding
         self.encoding = encoding
-      elsif /\A(?:\xfe\xff|\xff\xfe)/n =~ str
-        self.encoding = check_encoding( str )
-      elsif (0xef == str[0] && 0xbb == str[1])
+      elsif 0xfe == str[0] && 0xff == str[1]
+        @line_break = "\000>"
+      elsif 0xff == str[0] && 0xfe == str[1]
+        @line_break = ">\000"
+      elsif 0xef == str[0] && 0xbb == str[1]
         str += @source.read(1)
         str = '' if (0xbf == str[2])
+        @line_break = ">"
       else
-        @line_break = '>'
+        @line_break = ">"
       end
       super str+@source.readline( @line_break )
     end
Index: lib/rexml/attribute.rb
===================================================================
--- lib/rexml/attribute.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/attribute.rb	(.../v1_8_6_113)	(revision 14522)
@@ -50,7 +50,7 @@
 					@element = first.element
 				end
 			elsif first.kind_of? String
-				@element = parent if parent.kind_of? Element
+				@element = parent
 				self.name = first
 				@normalized = second.to_s
 			else
Index: lib/rexml/encoding.rb
===================================================================
--- lib/rexml/encoding.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/encoding.rb	(.../v1_8_6_113)	(revision 14522)
@@ -56,8 +56,13 @@
 
     def check_encoding str
       # We have to recognize UTF-16, LSB UTF-16, and UTF-8
-      return UTF_16 if /\A\xfe\xff/n =~ str
-      return UNILE if /\A\xff\xfe/n =~ str
+      if str[0] == 0xfe && str[1] == 0xff
+        str[0,2] = ""
+        return UTF_16
+      elsif str[0] == 0xff && str[1] == 0xfe
+        str[0,2] = ""
+        return UNILE
+      end
       str =~ /^\s*<\?xml\s+version\s*=\s*(['"]).*?\1\s+encoding\s*=\s*(["'])(.*?)\2/um
       return $3.upcase if $3
       return UTF_8
Index: lib/rexml/rexml.rb
===================================================================
--- lib/rexml/rexml.rb	(.../v1_8_6_111)	(revision 14522)
+++ lib/rexml/rexml.rb	(.../v1_8_6_113)	(revision 14522)
@@ -1,3 +1,4 @@
+# -*- encoding: utf-8 -*-
 # REXML is an XML toolkit for Ruby[http://www.ruby-lang.org], in Ruby.
 #
 # REXML is a _pure_ Ruby, XML 1.0 conforming,
@@ -10,8 +11,9 @@
 #
 # Main page:: http://www.germane-software.com/software/rexml
 # Author:: Sean Russell <serATgermaneHYPHENsoftwareDOTcom>
-# Version:: 3.1.7.1
-# Date:: 2007/209
+# Version:: 3.1.7.2
+# Date:: 2007/275
+# Revision:: $Revision$
 # 
 # This API documentation can be downloaded from the REXML home page, or can
 # be accessed online[http://www.germane-software.com/software/rexml_doc]
@@ -20,10 +22,10 @@
 # or can be accessed 
 # online[http://www.germane-software.com/software/rexml/docs/tutorial.html]
 module REXML
-  COPYRIGHT = "Copyright Â© 2001-2007 Sean Russell <ser@germane-software.com>"
-  DATE = "2007/209"
-  VERSION = "3.1.7.1"
-  REVISION = "$Revision: 1270$".gsub(/\$Revision:|\$/,'').strip
+  COPYRIGHT = "Copyright \xC2\xA9 2001-2006 Sean Russell <ser@germane-software.com>"
+  VERSION = "3.1.7.2"
+  DATE = "2007/275"
+  REVISION = "$Revision$".gsub(/\$Revision:|\$/,'').strip
 
   Copyright = COPYRIGHT
   Version = VERSION

Property changes on: lib/rexml/dtd/dtd.rb
___________________________________________________________________
Name: svk:merge
   + 3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/ruby-trunk/dtd/dtd.rb:1298


Property changes on: lib/rexml
___________________________________________________________________
Name: svk:merge
   - 3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/rexml-trunk/src/rexml:1287
3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/ruby-1.8.6:1339
3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/ruby-trunk:1335
877f57f0-f5bd-0310-8c13-bb9e5bdefd87:/branches/3.1.7/src/rexml:1274
b2dd03c8-39d4-4d8f-98ff-823fe69b080e:/trunk/lib/rexml:12517
   + 3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/rexml-trunk/src/rexml:1287
3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/rexml/trunk/src/rexml:1433
3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/ruby-1.8.6:1434
3a3bbbf4-582e-0410-a78b-8bf2211dae1f:/local/ruby-trunk:1380
877f57f0-f5bd-0310-8c13-bb9e5bdefd87:/branches/3.1.7/src/rexml:1274
b2dd03c8-39d4-4d8f-98ff-823fe69b080e:/trunk/lib/rexml:13097

Index: test/rss/test_taxonomy.rb
===================================================================
--- test/rss/test_taxonomy.rb	(.../v1_8_6_111)	(revision 14522)
+++ test/rss/test_taxonomy.rb	(.../v1_8_6_113)	(revision 14522)
@@ -144,8 +144,10 @@
       end
 
       @topic_nodes.each_with_index do |node, i|
-        expected = REXML::Document.new(node).root
-        actual = REXML::Document.new(@rss.taxo_topics[i].to_s(true, "")).root
+        expected_xml = taxo_xmlns_container(node)
+        expected = REXML::Document.new(expected_xml).root.elements[1]
+        actual_xml = taxo_xmlns_container(@rss.taxo_topics[i].to_s(true, ""))
+        actual = REXML::Document.new(actual_xml).root.elements[1]
         expected_elems = expected.reject {|x| x.is_a?(REXML::Text)}
         actual_elems = actual.reject {|x| x.is_a?(REXML::Text)}
         expected_elems.sort! {|x, y| x.name <=> y.name}
@@ -155,6 +157,16 @@
         assert_equal(expected.attributes.sort, actual.attributes.sort)
       end
     end
+
+    private
+    def taxo_xmlns_container(content)
+      xmlns_container({
+                        @prefix => @uri,
+                        "dc" => "http://purl.org/dc/elements/1.1/",
+                        "rdf" => "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
+                      },
+                      content)
+    end
   end
 end
 
Index: test/rss/rss-testcase.rb
===================================================================
--- test/rss/rss-testcase.rb	(.../v1_8_6_111)	(revision 14522)
+++ test/rss/rss-testcase.rb	(.../v1_8_6_113)	(revision 14522)
@@ -215,7 +215,14 @@
 
       "<#{h elem_name} #{attrs_str}>\n#{contents_str}\n</#{h elem_name}>"
     end
-    
+
+    def xmlns_container(xmlns_decls, content)
+      attributes = xmlns_decls.collect do |prefix, uri|
+        "xmlns:#{h prefix}=\"#{h uri}\""
+      end.join(" ")
+      "<dummy #{attributes}>#{content}</dummy>"
+    end
+
     private
     def setup_dummy_channel(maker)
       about = "http://hoge.com"
Index: test/rss/test_image.rb
===================================================================
--- test/rss/test_image.rb	(.../v1_8_6_111)	(revision 14522)
+++ test/rss/test_image.rb	(.../v1_8_6_113)	(revision 14522)
@@ -163,19 +163,23 @@
 
     def test_favicon_to_s
       favicon = @rss.channel.image_favicon
-      expected = REXML::Document.new(make_element("#{@prefix}:favicon",
-                                                  @favicon_attrs,
-                                                  @favicon_contents))
-      actual = REXML::Document.new(favicon.to_s(false, ""))
+      expected_xml = image_xmlns_container(make_element("#{@prefix}:favicon",
+                                                        @favicon_attrs,
+                                                        @favicon_contents))
+      expected = REXML::Document.new(expected_xml)
+      actual_xml = image_xmlns_container(favicon.to_s(false, ""))
+      actual = REXML::Document.new(actual_xml)
       assert_equal(expected.to_s, actual.to_s)
     end
 
     def test_item_to_s
       @rss.items.each_with_index do |item, i|
         attrs, contents = @items[i]
-        expected_s = make_element("#{@prefix}:item", attrs, contents)
-        expected = REXML::Document.new(expected_s)
-        actual = REXML::Document.new(item.image_item.to_s(false, ""))
+        expected_xml = make_element("#{@prefix}:item", attrs, contents)
+        expected_xml = image_xmlns_container(expected_xml)
+        expected = REXML::Document.new(expected_xml)
+        actual_xml = image_xmlns_container(item.image_item.to_s(false, ""))
+        actual = REXML::Document.new(actual_xml)
 
         assert_equal(expected[0].attributes, actual[0].attributes)
         
@@ -187,5 +191,14 @@
       end
     end
 
+    private
+    def image_xmlns_container(content)
+      xmlns_container({
+                        @prefix => @uri,
+                        "dc" => "http://purl.org/dc/elements/1.1/",
+                        "rdf" => "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
+                      },
+                      content)
+    end
   end
 end
Index: test/rss/test_parser_1.0.rb
===================================================================
--- test/rss/test_parser_1.0.rb	(.../v1_8_6_111)	(revision 14522)
+++ test/rss/test_parser_1.0.rb	(.../v1_8_6_113)	(revision 14522)
@@ -498,6 +498,15 @@
         Parser.parse(rss, true, false)
       end
     end
+
+    def test_unknown_duplicated_element
+      xmlns = {"test" => "http://localhost/test"}
+      assert_parse(make_RDF(<<-EOR, xmlns), :nothing_raised)
+        #{make_channel("<test:string/>")}
+        #{make_item}
+        #{make_image}
+      EOR
+    end
   end
 end
 
